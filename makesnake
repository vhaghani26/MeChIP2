#!/usr/bin/env python3
import argparse
import os
import re

parser = argparse.ArgumentParser(description='Make Snakefiles')
parser.add_argument('-o', '--output', type=str, metavar='<path>', required=True,
	help='output filename')
parser.add_argument('-r', '--read', type=str, metavar='<str>', required=True,
	help='input [single] for single end reads or [paired] for paired end readers')
parser.add_argument('--index_genome', type=str, metavar='<path>', required=False,
	help='path to genome fasta file to be indexed if genome not indexed')
parser.add_argument('-a', '--aligner', type=str, metavar='<str>', required=False,
	help='input sequence aligner {bwa_mem, bowtie2, STAR} (default: bwa_mem)',
	default='bwa_mem')
parser.add_argument('-p', '--peakcaller', type=str, metavar='<str>', required = False,
	help='input peak calling program {macs2, macs3} (default: macs3)', default='macs3')
parser.add_argument('-nd', '--no_deduplication', action='store_true',
	help='if tagged, bam files will not be deduplicated')
arg = parser.parse_args()

sf = open(arg.output, 'w')

genome_prefix = re.split('\.', re.split('/',arg.index_genome)[-1])[0]

# index genome
if arg.index_genome:
	if arg.aligner == 'bwa_mem':
		os.system(f'bwa index -p {genome_prefix} -a bwtsw {arg.index_genome}')
		os.system(f'mv {prefix}* data/')
	elif arg.aligner == 'bowtie2':
		os.system(f'bowtie2-build {arg.index_genome} data/{genome_prefix}')
	elif arg.aligner == 'STAR':
		os.system(f'STAR --runMode genomeGenerate --genomeDir data/genome --genomeFastaFiles {arg.index_genome}')

# align reads
# need to add options for single or paired end reads
with open(f'align_reads/{arg.aligner}.txt') as fh:
	align_rule = ''.join(fh.readlines())
	align_rule = re.sub('GENOME_PREFIX', prefix, align_rule)
	sf.write(f'{align_rule}\n')


# samtools
with open(f'samtools/samtools.txt') as fh:
	samtools_rule = ''.join(fh.readlines())
	sf.write(f'{samtools_rule}\n')
	
# dedup_reads
if arg.no_deduplication:
	with open(f'dedup_reads/fake_dedup.txt') as fh:
		dedup_rule = ''.join(fh.readlines())
		sf.write(f'{dedup_rule}\n')
else:
	with open(f'dedup_reads/sam_deduper.txt') as fh:
		dedup_rule = ''.join(fh.readlines())
		sf.write(f'{dedup_rule}\n')

# call_peaks
with open(f'call_peaks/{arg.peakcaller}.txt') as fh:
	callpeaks_rule = ''.join(fh.readlines())
	sf.write(f'{callpeaks_rule}\n')
	
# evaluate_peaks


sf.close()

